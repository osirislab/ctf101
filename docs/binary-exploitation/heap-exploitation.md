# Heap Exploits

## Overflow

Much like a [stack buffer overflow](./buffer-overflow/#stack-buffer-overflow), a **heap overflow** is a vulnerability where more data than can fit in the allocated buffer is read in. This could lead to heap metadata corruption, or corruption of other heap objects, which could in turn provide new attack surface.


## Use After Free (UAF)

Once `free` is called on an allocation, the allocator is free to re-allocate that chunk of memory in future calls to `malloc` if it so chooses. However if the program author isn't careful and uses the freed object later on, the contents may be corrupt (or even attacker controlled). This is called a use after free or UAF.

### Example

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

typedef struct string {
    unsigned length;
    char *data;
} string;

int main() {
    struct string* s = malloc(sizeof(string));
    puts("Length:");
    scanf("%u", &s->length);
    s->data = malloc(s->length + 1);
    memset(s->data, 0, s->length + 1);
    puts("Data:");
    read(0, s->data, s->length);

    free(s->data);
    free(s);

    char *s2 = malloc(16);
    memset(s2, 0, 16);
    puts("More data:");
    read(0, s2, 15);

    // Now using s again, a UAF

    puts(s->data);

    return 0;
}
```

In this example, we have a `string` structure with a length and a pointer to the actual string data. We properly allocate, fill, and then free an instance of this structure. Then we make another allocation, fill it, and then improperly reference the freed `string`. Due to how glibc's allocator works, `s2` will actually get the same memory as the original `s` allocation, which in turn gives us the ability to control the `s->data` pointer. This could be used to leak program data.

# Advanced Heap Exploitation

Not only can the heap be exploited by the data in allocations, but exploits can also use the underlying mechanisms in `malloc`, `free`, etc. to exploit a program. This is beyond the scope of CTF 101, but here are a few recommended resources:

* [sploitFUN's glibc overview](https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/)
* [Shellphish's how2heap](https://github.com/shellphish/how2heap)
